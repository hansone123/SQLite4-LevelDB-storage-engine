/*
** 2003 April 6
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
*************************************************************************
** This file contains code used to implement the PRAGMA command.
*/
#include "sqliteInt.h"
#include "bt.h"

/*
** Interpret the given string as a boolean value.
*/
u8 sqlite4GetBoolean(const char *z){
                             /* 123456789 12345 */
  static const char zText[] = "onoffalseyestrue";
  static const u8 iOffset[] = {0, 1, 2, 4, 9, 12};
  static const u8 iLength[] = {2, 2, 3, 5, 3, 4};
  static const u8 iValue[] =  {1, 0, 0, 0, 1, 1};
  int i, n;
  if( sqlite4Isdigit(*z) ){
    return (u8)sqlite4Atoi(z);
  }
  n = sqlite4Strlen30(z);
  for(i=0; i<ArraySize(iLength); i++){
    if( iLength[i]==n && sqlite4_strnicmp(&zText[iOffset[i]],z,n)==0 ){
      return iValue[i];
    }
  }
  return 1;
}

/* The sqlite4GetBoolean() function is used by other modules but the
** remainder of this file is specific to PRAGMA processing.  So omit
** the rest of the file if PRAGMAs are omitted from the build.
*/
#if !defined(SQLITE4_OMIT_PRAGMA)

/*
** Generate code to return a single integer value.
*/
static void returnSingleInt(Parse *pParse, const char *zLabel, i64 value){
  Vdbe *v = sqlite4GetVdbe(pParse);
  int mem = ++pParse->nMem;
  sqlite4_num *pNum;

  pNum = sqlite4DbMallocRaw(pParse->db, sizeof(value));
  if( pNum ){
    *pNum = sqlite4_num_from_int64(value);
  }
  sqlite4VdbeAddOp4(v, OP_Num, 1, mem, 0, (char *)pNum, P4_NUM);
  sqlite4VdbeSetNumCols(v, 1);
  sqlite4VdbeSetColName(v, 0, COLNAME_NAME, zLabel, SQLITE4_STATIC);
  sqlite4VdbeAddOp2(v, OP_ResultRow, mem, 1);
}

#ifndef SQLITE4_OMIT_FLAG_PRAGMAS
/*
** Check to see if zRight and zLeft refer to a pragma that queries
** or changes one of the flags in db->flags.  Return 1 if so and 0 if not.
** Also, implement the pragma.
*/
static int flagPragma(Parse *pParse, const char *zLeft, const char *zRight){
  static const struct sPragmaType {
    const char *zName;  /* Name of the pragma */
    int mask;           /* Mask for the db->flags value */
  } aPragma[] = {
    { "reverse_unordered_selects", SQLITE4_ReverseOrder  },
    { "automatic_index",           SQLITE4_AutoIndex  },
#ifdef SQLITE4_DEBUG
    { "sql_trace",                SQLITE4_SqlTrace      },
    { "vdbe_listing",             SQLITE4_VdbeListing   },
    { "vdbe_trace",               SQLITE4_VdbeTrace     },
    { "kv_trace",                 SQLITE4_KvTrace       },
    { "trace",                    SQLITE4_SqlTrace | SQLITE4_VdbeListing |
                                  SQLITE4_VdbeTrace | SQLITE4_KvTrace },
    { "vdbe_addoptrace",          SQLITE4_VdbeAddopTrace },
#endif
#ifndef SQLITE4_OMIT_CHECK
    { "ignore_check_constraints", SQLITE4_IgnoreChecks  },
#endif
    /* The following is VERY experimental */
    { "writable_schema",          SQLITE4_WriteSchema|SQLITE4_RecoveryMode },

    /* This flag may only be set if both foreign-key and trigger support
    ** are present in the build.  */
#if !defined(SQLITE4_OMIT_FOREIGN_KEY) && !defined(SQLITE4_OMIT_TRIGGER)
    { "foreign_keys",             SQLITE4_ForeignKeys },
#endif
  };
  int i, j;
  const struct sPragmaType *p;
  for(i=0, p=aPragma; i<ArraySize(aPragma); i++, p++){
    if( sqlite4_stricmp(zLeft, p->zName)==0 ){
      sqlite4 *db = pParse->db;
      Vdbe *v;
      v = sqlite4GetVdbe(pParse);
      assert( v!=0 );  /* Already allocated by sqlite4Pragma() */
      if( ALWAYS(v) ){
        if( zRight==0 ){
          returnSingleInt(pParse, p->zName, (db->flags & p->mask)!=0 );
        }else{
          int mask = p->mask;          /* Mask of bits to set or clear. */
          if( db->pSavepoint ){
            /* Foreign key support may not be enabled or disabled while not
            ** in auto-commit mode.  */
            mask &= ~(SQLITE4_ForeignKeys);
          }

          if( sqlite4GetBoolean(zRight) ){
            db->flags |= mask;
          }else{
            db->flags &= ~mask;
          }

          /* Many of the flag-pragmas modify the code generated by the SQL 
          ** compiler (eg. count_changes). So add an opcode to expire all
          ** compiled SQL statements after modifying a pragma value.
          */
          sqlite4VdbeAddOp2(v, OP_Expire, 0, 0);
        }
        for(j=0; j<db->nDb; j++){
          if( db->aDb[j].pKV ){
            db->aDb[j].pKV->fTrace = (db->flags & SQLITE4_KvTrace)!=0;
          }
        }
      }

      return 1;
    }
  }
  return 0;
}
#endif /* SQLITE4_OMIT_FLAG_PRAGMAS */

/*
** Return a human-readable name for a constraint resolution action.
*/
#ifndef SQLITE4_OMIT_FOREIGN_KEY
static const char *actionName(u8 action){
  const char *zName;
  switch( action ){
    case OE_SetNull:  zName = "SET NULL";        break;
    case OE_SetDflt:  zName = "SET DEFAULT";     break;
    case OE_Cascade:  zName = "CASCADE";         break;
    case OE_Restrict: zName = "RESTRICT";        break;
    default:          zName = "NO ACTION";  
                      assert( action==OE_None ); break;
  }
  return zName;
}
#endif

/*
** Prepare an SQL PRAGMA statement.
*/
void sqlite4Pragma(
  Parse *pParse,      /* Parse context */
  Token *pId1,        /* First part of [database.]id field */
  Token *pId2,        /* Second part of [database.]id field, or {0, 0} */
  ExprList *pList     /* List of pragma arguments */
){
  sqlite4 *db = pParse->db;
  Vdbe *v = pParse->pVdbe = sqlite4VdbeCreate(db);
  Token *pPragma;                 /* Token containing name of PRAGMA */
  char *zPragma = 0;              /* Name of requested PRAGMA */
  char *zRight = 0;               /* Argument to built-in pragmas */
  int iDb;                        /* Index of affected database */
  const char *zDb;                /* Named database (or NULL) */
  int rc = SQLITE4_OK;            /* Error code */
  KVStore *pKV;                   /* KV store corresponding to db iDb */

  /* Interpret the [database.] part of the pragma statement. iDb is the
  ** index of the database this pragma is being applied to in db.aDb[]. */
  iDb = sqlite4TwoPartName(pParse, pId1, pId2, &pPragma);
  if( iDb<0 ) goto pragma_out;
  zPragma = sqlite4NameFromToken(db, pPragma);
  if( !zPragma ) goto pragma_out;

  assert( pId2 );
  zDb = pId2->n>0 ? db->aDb[iDb].zName : 0;

  /* If this pragma is to operate on the temp database, make sure it is open. */
  if( iDb==1 && sqlite4OpenTempDatabase(pParse) ){
    goto pragma_out;
  }

  /* If a database was named as part of the pragma command, check to see if
  ** this is a custom key-value store pragma. */
  pKV = db->aDb[iDb].pKV;
  if( pKV->pStoreVfunc->xGetMethod ){
    void (*xFunc)(sqlite4_context *, int, sqlite4_value **);
    void (*xDestroy)(void *);
    void *pArg;

    rc = pKV->pStoreVfunc->xGetMethod(pKV, zPragma, &pArg, &xFunc, &xDestroy);
    if( rc==SQLITE4_OK ){
      FuncDef *pDef;
      int r1 = 0;
      int regOut;               /* Result register */

      if( sqlite4AuthCheck(pParse, SQLITE4_PRAGMA, zPragma, 0, zDb) ){
        goto pragma_out;
      }

      pDef = (FuncDef *)sqlite4DbMallocZero(db, sizeof(FuncDef));
      if( !pDef ) goto pragma_out;
      pDef->flags = SQLITE4_FUNC_EPHEM;
      pDef->pUserData = pArg;
      pDef->xFunc = xFunc;
      pDef->xDestroy = xDestroy;

      sqlite4VdbeSetNumCols(v, 1);
      sqlite4VdbeSetColName(v, 0, COLNAME_NAME, zPragma, SQLITE4_TRANSIENT);

      if( pList ){
        r1 = pParse->nMem+1;
        pParse->nMem += pList->nExpr;
        sqlite4ExprCodeExprList(pParse, pList, r1, 0);
        pDef->nArg = pList->nExpr;
      }

      regOut = ++pParse->nMem;
      sqlite4VdbeAddOp1(v, OP_KVMethod, iDb);
      sqlite4VdbeAddOp3(v, OP_Function, 0, r1, regOut);
      sqlite4VdbeChangeP4(v, -1, (char*)pDef, P4_FUNCDEF);
      if( pList ) sqlite4VdbeChangeP5(v, pList->nExpr);
      sqlite4VdbeAddOp2(v, OP_ResultRow, regOut, 1);
      goto pragma_out;

    }else if( rc==SQLITE4_NOTFOUND ){
      rc = SQLITE4_OK;
    }else{
      goto pragma_out;
    }
  }

  pParse->nMem = 2;
  sqlite4VdbeRunOnlyOnce(v);
  zRight = 0;
  if( pList ){
    zRight = pList->a[0].zSpan;
    if( zRight==0 ){ 
      assert( pList->a[0].pExpr->op==TK_ID );
      zRight = pList->a[0].pExpr->u.zToken; 
    }
    sqlite4Dequote(zRight);
  }

  if( sqlite4AuthCheck(pParse, SQLITE4_PRAGMA, zPragma, zRight, zDb) ){
    goto pragma_out;
  }

#ifndef SQLITE4_OMIT_FLAG_PRAGMAS
  if( flagPragma(pParse, zPragma, zRight) ){
    /* The flagPragma() subroutine also generates any necessary code
    ** there is nothing more to do here */
  }else
#endif /* SQLITE4_OMIT_FLAG_PRAGMAS */

  /*
  **   PRAGMA fts_check(<index>)
  */
  if( sqlite4_stricmp(zPragma, "fts_check")==0 && zRight ){
    int iCksum1;
    int iCksum2;
    Index *pIdx;
    Table *pTab;
    Vdbe *v = sqlite4GetVdbe(pParse);
    if( v==0 || sqlite4ReadSchema(pParse) ) goto pragma_out;

    iCksum1 = ++pParse->nMem;
    iCksum2 = ++pParse->nMem;
    sqlite4VdbeAddOp2(v, OP_Integer, 0, iCksum1);
    sqlite4VdbeAddOp2(v, OP_Integer, 0, iCksum2);

    pIdx = sqlite4FindIndex(db, zRight, zDb);
    if( pIdx && pIdx->eIndexType==SQLITE4_INDEX_FTS5 ){
      int iTab = pParse->nTab++;
      int iAddr;
      int iReg;
      int i;

      pTab = pIdx->pTable;
      sqlite4OpenPrimaryKey(pParse, iTab, iDb, pTab, OP_OpenRead);
      iAddr = sqlite4VdbeAddOp2(v, OP_Rewind, iTab, 0);

      iReg = pParse->nMem+1;
      pParse->nMem += (1 + pTab->nCol);

      sqlite4VdbeAddOp2(v, OP_RowKey, iTab, iReg);
      for(i=0; i<pTab->nCol; i++){
        sqlite4VdbeAddOp3(v, OP_Column, iTab, i, iReg+1+i);
      }
      sqlite4Fts5CodeCksum(pParse, pIdx, iCksum1, iReg, 0);

      sqlite4VdbeAddOp2(v, OP_Next, iTab, iAddr+1);
      sqlite4VdbeJumpHere(v, iAddr);
      sqlite4VdbeAddOp1(v, OP_Close, iTab);

      sqlite4VdbeAddOp3(v, OP_OpenRead, iTab, pIdx->tnum, iDb);
      iAddr = sqlite4VdbeAddOp2(v, OP_Rewind, iTab, 0);

      iReg = pParse->nMem+1;
      pParse->nMem += 2;
      sqlite4VdbeAddOp2(v, OP_RowKey, iTab, iReg);
      sqlite4VdbeAddOp2(v, OP_RowData, iTab, iReg+1);
      sqlite4Fts5CodeCksum(pParse, pIdx, iCksum2, iReg, 1);

      sqlite4VdbeAddOp2(v, OP_Next, iTab, iAddr+1);
      sqlite4VdbeJumpHere(v, iAddr);
      sqlite4VdbeAddOp1(v, OP_Close, iTab);

      iReg = ++pParse->nMem;
      sqlite4VdbeAddOp4(v, OP_String8, 0, iReg, 0, "ok", 0);
      iAddr = sqlite4VdbeAddOp3(v, OP_Eq, iCksum1, 0, iCksum2);
      sqlite4VdbeAddOp4(v, OP_String8, 0, iReg, 0, "error - cksum mismatch", 0);
      sqlite4VdbeJumpHere(v, iAddr);
      sqlite4VdbeAddOp2(v, OP_ResultRow, iReg, 1);

      sqlite4VdbeSetNumCols(v, 1);
    }
  }

#ifndef SQLITE4_OMIT_SCHEMA_PRAGMAS
  /*
  **   PRAGMA table_info(<table>)
  **
  ** Return a single row for each column of the named table. The columns of
  ** the returned data set are:
  **
  ** cid:        Column id (numbered from left to right, starting at 0)
  ** name:       Column name
  ** type:       Column declaration type.
  ** notnull:    True if 'NOT NULL' is part of column declaration
  ** dflt_value: The default value for the column, if any.
  */
  if( sqlite4_stricmp(zPragma, "table_info")==0 && zRight ){
    Table *pTab;
    if( sqlite4ReadSchema(pParse) ) goto pragma_out;
    pTab = sqlite4FindTable(db, zRight, zDb);
    if( pTab ){
      int i;
      int nHidden = 0;
      Column *pCol;
      sqlite4VdbeSetNumCols(v, 6);
      pParse->nMem = 6;
      sqlite4VdbeSetColName(v, 0, COLNAME_NAME, "cid", SQLITE4_STATIC);
      sqlite4VdbeSetColName(v, 1, COLNAME_NAME, "name", SQLITE4_STATIC);
      sqlite4VdbeSetColName(v, 2, COLNAME_NAME, "type", SQLITE4_STATIC);
      sqlite4VdbeSetColName(v, 3, COLNAME_NAME, "notnull", SQLITE4_STATIC);
      sqlite4VdbeSetColName(v, 4, COLNAME_NAME, "dflt_value", SQLITE4_STATIC);
      sqlite4VdbeSetColName(v, 5, COLNAME_NAME, "pk", SQLITE4_STATIC);
      sqlite4ViewGetColumnNames(pParse, pTab);
      for(i=0, pCol=pTab->aCol; i<pTab->nCol; i++, pCol++){
        if( IsHiddenColumn(pCol) ){
          nHidden++;
          continue;
        }
        sqlite4VdbeAddOp2(v, OP_Integer, i-nHidden, 1);
        sqlite4VdbeAddOp4(v, OP_String8, 0, 2, 0, pCol->zName, 0);
        sqlite4VdbeAddOp4(v, OP_String8, 0, 3, 0,
           pCol->zType ? pCol->zType : "", 0);
        sqlite4VdbeAddOp2(v, OP_Integer, (pCol->notNull ? 1 : 0), 4);
        if( pCol->zDflt ){
          sqlite4VdbeAddOp4(v, OP_String8, 0, 5, 0, (char*)pCol->zDflt, 0);
        }else{
          sqlite4VdbeAddOp2(v, OP_Null, 0, 5);
        }
        sqlite4VdbeAddOp2(v, OP_Integer, pCol->iPrimKey, 6);
        sqlite4VdbeAddOp2(v, OP_ResultRow, 1, 6);
      }
    }
  }else

  if( sqlite4_stricmp(zPragma, "index_info")==0 && zRight ){
    Index *pIdx;
    Table *pTab;
    if( sqlite4ReadSchema(pParse) ) goto pragma_out;
    pIdx = sqlite4FindIndex(db, zRight, zDb);
    if( pIdx ){
      int i;
      pTab = pIdx->pTable;
      sqlite4VdbeSetNumCols(v, 3);
      pParse->nMem = 3;
      sqlite4VdbeSetColName(v, 0, COLNAME_NAME, "seqno", SQLITE4_STATIC);
      sqlite4VdbeSetColName(v, 1, COLNAME_NAME, "cid", SQLITE4_STATIC);
      sqlite4VdbeSetColName(v, 2, COLNAME_NAME, "name", SQLITE4_STATIC);
      for(i=0; i<pIdx->nColumn; i++){
        int cnum = pIdx->aiColumn[i];
        sqlite4VdbeAddOp2(v, OP_Integer, i, 1);
        sqlite4VdbeAddOp2(v, OP_Integer, cnum, 2);
        assert( pTab->nCol>cnum );
        sqlite4VdbeAddOp4(v, OP_String8, 0, 3, 0, pTab->aCol[cnum].zName, 0);
        sqlite4VdbeAddOp2(v, OP_ResultRow, 1, 3);
      }
    }
  }else

  if( sqlite4_stricmp(zPragma, "index_list")==0 && zRight ){
    Index *pIdx;
    Table *pTab;
    if( sqlite4ReadSchema(pParse) ) goto pragma_out;
    pTab = sqlite4FindTable(db, zRight, zDb);
    if( pTab ){
      v = sqlite4GetVdbe(pParse);
      pIdx = pTab->pIndex;
      if( pIdx ){
        int i = 0; 
        sqlite4VdbeSetNumCols(v, 3);
        pParse->nMem = 3;
        sqlite4VdbeSetColName(v, 0, COLNAME_NAME, "seq", SQLITE4_STATIC);
        sqlite4VdbeSetColName(v, 1, COLNAME_NAME, "name", SQLITE4_STATIC);
        sqlite4VdbeSetColName(v, 2, COLNAME_NAME, "unique", SQLITE4_STATIC);
        while(pIdx){
          sqlite4VdbeAddOp2(v, OP_Integer, i, 1);
          sqlite4VdbeAddOp4(v, OP_String8, 0, 2, 0, pIdx->zName, 0);
          sqlite4VdbeAddOp2(v, OP_Integer, pIdx->onError!=OE_None, 3);
          sqlite4VdbeAddOp2(v, OP_ResultRow, 1, 3);
          ++i;
          pIdx = pIdx->pNext;
        }
      }
    }
  }else

  if( sqlite4_stricmp(zPragma, "database_list")==0 ){
    int i;
    if( sqlite4ReadSchema(pParse) ) goto pragma_out;
    sqlite4VdbeSetNumCols(v, 2);
    pParse->nMem = 3;
    sqlite4VdbeSetColName(v, 0, COLNAME_NAME, "seq", SQLITE4_STATIC);
    sqlite4VdbeSetColName(v, 1, COLNAME_NAME, "name", SQLITE4_STATIC);
    for(i=0; i<db->nDb; i++){
      if( db->aDb[i].pKV==0 ) continue;
      assert( db->aDb[i].zName!=0 );
      sqlite4VdbeAddOp2(v, OP_Integer, i, 1);
      sqlite4VdbeAddOp4(v, OP_String8, 0, 2, 0, db->aDb[i].zName, 0);
      sqlite4VdbeAddOp2(v, OP_ResultRow, 1, 2);
    }
  }else

  if( sqlite4_stricmp(zPragma, "collation_list")==0 ){
    int i = 0;
    HashElem *p;
    sqlite4VdbeSetNumCols(v, 2);
    pParse->nMem = 2;
    sqlite4VdbeSetColName(v, 0, COLNAME_NAME, "seq", SQLITE4_STATIC);
    sqlite4VdbeSetColName(v, 1, COLNAME_NAME, "name", SQLITE4_STATIC);
    for(p=sqliteHashFirst(&db->aCollSeq); p; p=sqliteHashNext(p)){
      CollSeq *pColl = (CollSeq *)sqliteHashData(p);
      sqlite4VdbeAddOp2(v, OP_Integer, i++, 1);
      sqlite4VdbeAddOp4(v, OP_String8, 0, 2, 0, pColl->zName, 0);
      sqlite4VdbeAddOp2(v, OP_ResultRow, 1, 2);
    }
  }else
#endif /* SQLITE4_OMIT_SCHEMA_PRAGMAS */

#ifndef SQLITE4_OMIT_FOREIGN_KEY
  if( sqlite4_stricmp(zPragma, "foreign_key_list")==0 && zRight ){
    FKey *pFK;
    Table *pTab;
    if( sqlite4ReadSchema(pParse) ) goto pragma_out;
    pTab = sqlite4FindTable(db, zRight, zDb);
    if( pTab ){
      v = sqlite4GetVdbe(pParse);
      pFK = pTab->pFKey;
      if( pFK ){
        int i = 0; 
        sqlite4VdbeSetNumCols(v, 8);
        pParse->nMem = 8;
        sqlite4VdbeSetColName(v, 0, COLNAME_NAME, "id", SQLITE4_STATIC);
        sqlite4VdbeSetColName(v, 1, COLNAME_NAME, "seq", SQLITE4_STATIC);
        sqlite4VdbeSetColName(v, 2, COLNAME_NAME, "table", SQLITE4_STATIC);
        sqlite4VdbeSetColName(v, 3, COLNAME_NAME, "from", SQLITE4_STATIC);
        sqlite4VdbeSetColName(v, 4, COLNAME_NAME, "to", SQLITE4_STATIC);
        sqlite4VdbeSetColName(v, 5, COLNAME_NAME, "on_update", SQLITE4_STATIC);
        sqlite4VdbeSetColName(v, 6, COLNAME_NAME, "on_delete", SQLITE4_STATIC);
        sqlite4VdbeSetColName(v, 7, COLNAME_NAME, "match", SQLITE4_STATIC);
        while(pFK){
          int j;
          for(j=0; j<pFK->nCol; j++){
            char *zCol = pFK->aCol[j].zCol;
            char *zOnDelete = (char *)actionName(pFK->aAction[0]);
            char *zOnUpdate = (char *)actionName(pFK->aAction[1]);
            sqlite4VdbeAddOp2(v, OP_Integer, i, 1);
            sqlite4VdbeAddOp2(v, OP_Integer, j, 2);
            sqlite4VdbeAddOp4(v, OP_String8, 0, 3, 0, pFK->zTo, 0);
            sqlite4VdbeAddOp4(v, OP_String8, 0, 4, 0,
                              pTab->aCol[pFK->aCol[j].iFrom].zName, 0);
            sqlite4VdbeAddOp4(v, zCol ? OP_String8 : OP_Null, 0, 5, 0, zCol, 0);
            sqlite4VdbeAddOp4(v, OP_String8, 0, 6, 0, zOnUpdate, 0);
            sqlite4VdbeAddOp4(v, OP_String8, 0, 7, 0, zOnDelete, 0);
            sqlite4VdbeAddOp4(v, OP_String8, 0, 8, 0, "NONE", 0);
            sqlite4VdbeAddOp2(v, OP_ResultRow, 1, 8);
          }
          ++i;
          pFK = pFK->pNextFrom;
        }
      }
    }
  }else
#endif /* !defined(SQLITE4_OMIT_FOREIGN_KEY) */

#ifndef NDEBUG
  if( sqlite4_stricmp(zPragma, "parser_trace")==0 ){
    if( zRight ){
      if( sqlite4GetBoolean(zRight) ){
        sqlite4ParserTrace(stderr, "parser: ");
      }else{
        sqlite4ParserTrace(0, 0);
      }
    }
  }else
#endif

  /* Reinstall the LIKE and GLOB functions.  The variant of LIKE
  ** used will be case sensitive or not depending on the RHS.
  */
  if( sqlite4_stricmp(zPragma, "case_sensitive_like")==0 ){
    if( zRight ){
      sqlite4RegisterLikeFunctions(db, sqlite4GetBoolean(zRight));
    }
  }else

#ifndef SQLITE4_INTEGRITY_CHECK_ERROR_MAX
# define SQLITE4_INTEGRITY_CHECK_ERROR_MAX 100
#endif


#ifndef SQLITE4_OMIT_UTF16
  /*
  **   PRAGMA encoding
  **   PRAGMA encoding = "utf-8"|"utf-16"|"utf-16le"|"utf-16be"
  **
  ** In its first form, this pragma returns the encoding of the main
  ** database. If the database is not initialized, it is initialized now.
  **
  ** The second form of this pragma is a no-op if the main database file
  ** has not already been initialized. In this case it sets the default
  ** encoding that will be used for the main database file if a new file
  ** is created. If an existing main database file is opened, then the
  ** default text encoding for the existing database is used.
  ** 
  ** In all cases new databases created using the ATTACH command are
  ** created to use the same default text encoding as the main database. If
  ** the main database has not been initialized and/or created when ATTACH
  ** is executed, this is done before the ATTACH operation.
  **
  ** In the second form this pragma sets the text encoding to be used in
  ** new database files created using this database handle. It is only
  ** useful if invoked immediately after the main database i
  */
  if( sqlite4_stricmp(zPragma, "encoding")==0 ){
    static const struct EncName {
      char *zName;
      u8 enc;
    } encnames[] = {
      { "UTF8",     SQLITE4_UTF8        },
      { "UTF-8",    SQLITE4_UTF8        },  /* Must be element [1] */
      { "UTF-16le", SQLITE4_UTF16LE     },  /* Must be element [2] */
      { "UTF-16be", SQLITE4_UTF16BE     },  /* Must be element [3] */
      { "UTF16le",  SQLITE4_UTF16LE     },
      { "UTF16be",  SQLITE4_UTF16BE     },
      { "UTF-16",   0                  }, /* SQLITE4_UTF16NATIVE */
      { "UTF16",    0                  }, /* SQLITE4_UTF16NATIVE */
      { 0, 0 }
    };
    const struct EncName *pEnc;
    if( !zRight ){    /* "PRAGMA encoding" */
      if( sqlite4ReadSchema(pParse) ) goto pragma_out;
      sqlite4VdbeSetNumCols(v, 1);
      sqlite4VdbeSetColName(v, 0, COLNAME_NAME, "encoding", SQLITE4_STATIC);
      sqlite4VdbeAddOp2(v, OP_String8, 0, 1);
      assert( encnames[SQLITE4_UTF8].enc==SQLITE4_UTF8 );
      assert( encnames[SQLITE4_UTF16LE].enc==SQLITE4_UTF16LE );
      assert( encnames[SQLITE4_UTF16BE].enc==SQLITE4_UTF16BE );
      sqlite4VdbeChangeP4(v, -1, encnames[ENC(pParse->db)].zName, P4_STATIC);
      sqlite4VdbeAddOp2(v, OP_ResultRow, 1, 1);
    }else{                        /* "PRAGMA encoding = XXX" */
      /* Only change the value of sqlite.enc if the database handle is not
      ** initialized. If the main database exists, the new sqlite.enc value
      ** will be overwritten when the schema is next loaded. If it does not
      ** already exists, it will be created to use the new encoding value.
      */
      if( 
        !(DbHasProperty(db, 0, DB_SchemaLoaded)) || 
        DbHasProperty(db, 0, DB_Empty) 
      ){
        for(pEnc=&encnames[0]; pEnc->zName; pEnc++){
          if( 0==sqlite4_stricmp(zRight, pEnc->zName) ){
            ENC(pParse->db) = pEnc->enc ? pEnc->enc : SQLITE4_UTF16NATIVE;
            break;
          }
        }
        if( !pEnc->zName ){
          sqlite4ErrorMsg(pParse, "unsupported encoding: %s", zRight);
        }
      }
    }
  }else
#endif /* SQLITE4_OMIT_UTF16 */


#ifndef SQLITE4_OMIT_COMPILEOPTION_DIAGS
  /*
  **   PRAGMA compile_options
  **
  ** Return the names of all compile-time options used in this build,
  ** one option per row.
  */
  if( sqlite4_stricmp(zPragma, "compile_options")==0 ){
    int i = 0;
    const char *zOpt;
    sqlite4VdbeSetNumCols(v, 1);
    pParse->nMem = 1;
    sqlite4VdbeSetColName(v, 0, COLNAME_NAME, "compile_option", SQLITE4_STATIC);
    while( (zOpt = sqlite4_compileoption_get(i++))!=0 ){
      sqlite4VdbeAddOp4(v, OP_String8, 0, 1, 0, zOpt, 0);
      sqlite4VdbeAddOp2(v, OP_ResultRow, 1, 1);
    }
  }else
#endif /* SQLITE4_OMIT_COMPILEOPTION_DIAGS */

#ifdef SQLITE4_DEBUG
  /*
  **   PRAGMA kvdump
  **
  ** Print an ascii rendering of the complete content of the database file.
  */
  if( sqlite4_stricmp(zPragma, "kvdump")==0 ){
    sqlite4KVStoreDump(db->aDb[0].pKV);
  }else

  /*
  **   PRAGMA kvreplace(BLOB,BLOB)
  **
  ** Insert or replace a single raw record into the KV store.  This pragma
  ** is exceedingly dangerous and should not be used by general-purpose
  ** applications.  It is intended for internal testing only - to provide
  ** a convenient way to insert arbitrary content into the key/value store.
  */
  if( sqlite4_stricmp(zPragma, "kvreplace")==0
   && pList->nExpr==2
  ){
    int r1, r2;
    Vdbe *v = sqlite4GetVdbe(pParse);
    pParse->nTab = 1;
    pParse->nMem = 3;
    sqlite4BeginWriteOperation(pParse, 0, iDb);
    r1 = sqlite4ExprCodeTarget(pParse, pList->a[0].pExpr, 1);
    sqlite4VdbeAddOp4(v, OP_HaltIfNull, SQLITE4_CONSTRAINT, OE_Abort,
                         r1, "key may not be null", P4_STATIC);
    sqlite4VdbeAddOp1(v, OP_ToBlob, r1);
    r2 = sqlite4ExprCodeTarget(pParse, pList->a[1].pExpr, 2);
    sqlite4VdbeAddOp4(v, OP_HaltIfNull, SQLITE4_CONSTRAINT, OE_Abort,
                         r2, "value may not be null", P4_STATIC);
    sqlite4VdbeAddOp1(v, OP_ToBlob, r2);
    sqlite4VdbeAddOp0(v, OP_OpenWrite);
    sqlite4VdbeAddOp3(v, OP_Insert, 0, r2, r1);
    sqlite4VdbeAddOp0(v, OP_Halt);
  }else
#endif /* SQLITE4_DEBUG */

  /*
  **   PRAGMA integrity_check
  **
  ** Check that for each table, the content of any auxilliary indexes are 
  ** consistent with the primary key index.
  */
  if( sqlite4_stricmp(zPragma, "integrity_check")==0 ){
    const int baseCsr = 1;        /* Base cursor for OpenAllIndexes() call */

    const int regErrcnt = 1;      /* Register containing error count */
    const int regErrstr = 2;      /* Register containing error string */
    const int regTmp = 3;         /* Register for tmp use */
    const int regRowcnt1 = 4;     /* Register containing row count (from PK) */
    const int regRowcnt2 = 5;     /* Register containing error count */
    const int regResult = 6;      /* Register containing result string */
    const int regKey = 7;         /* Register containing encoded key */
    const int regArray = 8;       /* First in array of registers */

    int i;
    int nMaxArray = 1;
    int addrNot = 0;
    Vdbe *v;

    if( sqlite4ReadSchema(pParse) ) goto pragma_out;

    for(i=0; i<db->nDb; i++){
      if( OMIT_TEMPDB && i==1 ) continue;
      sqlite4CodeVerifySchema(pParse, i);
    }

    v = sqlite4GetVdbe(pParse);
    sqlite4VdbeAddOp2(v, OP_Integer, 0, regErrcnt);
    sqlite4VdbeAddOp4(v, OP_String8, 0, regErrstr, 0, "", 0);

    for(i=0; i<db->nDb; i++){
      Hash *pTbls;
      HashElem *x;

      if( OMIT_TEMPDB && i==1 ) continue;

      pTbls = &db->aDb[i].pSchema->tblHash;
      for(x=sqliteHashFirst(pTbls); x; x=sqliteHashNext(x)){
        Index *pIdx;
        Table *pTab = (Table *)sqliteHashData(x);
        int addrRewind;
        int nIdx = 0;
        int iPkCsr;
        Index *pPk;
        int iCsr;

        /* Do nothing for views or sqlite_kvstore */
        if( IsView(pTab) || IsKvstore(pTab) ) continue;

        /* Open all indexes for table pTab. */
        for(pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext){
          if( pIdx->eIndexType==SQLITE4_INDEX_PRIMARYKEY ){
            pPk = pIdx;
            iPkCsr = nIdx+baseCsr;
          }
          nIdx++;
        }
        sqlite4OpenAllIndexes(pParse, pTab, baseCsr, OP_OpenRead);

        sqlite4VdbeAddOp2(v, OP_Integer, 0, regRowcnt1);
        addrRewind = sqlite4VdbeAddOp1(v, OP_Rewind, iPkCsr);

        /* Increment the row-count register */
        sqlite4VdbeAddOp2(v, OP_AddImm, regRowcnt1, 1);

        for(iCsr=baseCsr, pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext, iCsr++){
          assert( (pIdx->eIndexType==SQLITE4_INDEX_PRIMARYKEY)==(iCsr==iPkCsr) );
          if( iCsr!=iPkCsr ){
            char *zErr;
            int iCol;
            int jmp;
            for(iCol=0; iCol<pIdx->nColumn; iCol++){
              int r = regArray + iCol;
              sqlite4VdbeAddOp3(v, OP_Column, iPkCsr, pIdx->aiColumn[iCol], r);
              assert( pIdx->aiColumn[iCol]>=0 );
            }
            for(iCol=0; iCol<pPk->nColumn; iCol++){
              int reg = regArray + pIdx->nColumn + iCol;
              int iTblCol = pPk->aiColumn[iCol];
              if( iTblCol<0 ){
                sqlite4VdbeAddOp2(v, OP_Rowid, iPkCsr, reg);
              }else{
                sqlite4VdbeAddOp3(v, OP_Column, iPkCsr, iTblCol, reg);
              }
            }

            if( (pPk->nColumn+pIdx->nColumn)>nMaxArray ){
              nMaxArray = pPk->nColumn + pIdx->nColumn;
            }

            sqlite4VdbeAddOp4Int(v, OP_MakeKey, regArray,
                                 pIdx->nColumn+pPk->nColumn, regKey, iCsr);
            jmp = sqlite4VdbeAddOp4(v, OP_Found, iCsr, 0, regKey, 0, P4_INT32);
            sqlite4VdbeAddOp2(v, OP_AddImm, regErrcnt, 1);
            zErr = sqlite4MPrintf(
                db, "entry missing from index %s: ", pIdx->zName
            );
            sqlite4VdbeAddOp4(v, OP_String8, 0, regTmp, 0, zErr, 0);
            sqlite4VdbeAddOp3(v, OP_Concat, regTmp, regErrstr, regErrstr);
            sqlite4VdbeAddOp3(v, OP_Function, 0, regKey, regTmp);
            sqlite4VdbeChangeP4(v, -1,
                (char *)sqlite4FindFunction(db, "hex", 3, 1, 0), 
                P4_FUNCDEF
            );
            sqlite4VdbeChangeP5(v, 1);
            sqlite4VdbeAddOp3(v, OP_Concat, regTmp, regErrstr, regErrstr);
            sqlite4VdbeAddOp4(v, OP_String8, 0, regTmp, 0, "\n", 0);
            sqlite4VdbeAddOp3(v, OP_Concat, regTmp, regErrstr, regErrstr);
            sqlite4VdbeJumpHere(v, jmp);
            sqlite4DbFree(db, zErr);
          }
        }
        sqlite4VdbeAddOp2(v, OP_Next, iPkCsr, addrRewind+1);
        sqlite4VdbeJumpHere(v, addrRewind);

        for(iCsr=baseCsr, pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext, iCsr++){
          if( iCsr!=iPkCsr ){
            char *zErr;
            int addrEq;
            int addrRewind2;
            sqlite4VdbeAddOp2(v, OP_Integer, 0, regRowcnt2);
            addrRewind2 = sqlite4VdbeAddOp1(v, OP_Rewind, iCsr);
            sqlite4VdbeAddOp2(v, OP_AddImm, regRowcnt2, 1);
            sqlite4VdbeAddOp2(v, OP_Next, iCsr, addrRewind2+1);
            sqlite4VdbeJumpHere(v, addrRewind2);
            zErr = sqlite4MPrintf(
                db, "wrong # number of entries in index %s\n", pIdx->zName
            );
            addrEq = sqlite4VdbeAddOp3(v, OP_Eq, regRowcnt1, 0, regRowcnt2);
            sqlite4VdbeAddOp2(v, OP_AddImm, regErrcnt, 1);
            sqlite4VdbeAddOp4(v, OP_String8, 0, regTmp, 0, zErr, 0);
            sqlite4VdbeAddOp3(v, OP_Concat, regTmp, regErrstr, regErrstr);

            sqlite4VdbeJumpHere(v, addrEq);
            sqlite4DbFree(db, zErr);
          }
        }

        for(iCsr=baseCsr; iCsr<(baseCsr+nIdx); iCsr++){
          sqlite4VdbeAddOp1(v, OP_Close, iCsr);
        }
      }
    }

    sqlite4VdbeAddOp4(v, OP_String8, 0, regResult, 0, "ok", 0);
    addrNot = sqlite4VdbeAddOp1(v, OP_IfNot, regErrcnt);
    sqlite4VdbeAddOp4(v, OP_String8, 0, regArray, 0, " errors:\n", 0);
    sqlite4VdbeAddOp3(v, OP_Concat, regArray, regErrcnt, regResult);
    sqlite4VdbeAddOp3(v, OP_Concat, regErrstr, regResult, regResult);
    sqlite4VdbeJumpHere(v, addrNot);

    pParse->nMem = (regArray + nMaxArray);
    sqlite4VdbeSetNumCols(v, 1);
    sqlite4VdbeSetColName(v, 0, COLNAME_NAME, "integrity_check", SQLITE4_STATIC);
    sqlite4VdbeAddOp2(v, OP_ResultRow, regResult, 1);

  }else


  /*
  **  PRAGMA shrink_memory
  **
  ** This pragma attempts to free as much memory as possible from the
  ** current database connection.
  */
  if( sqlite4_stricmp(zPragma, "shrink_memory")==0 ){
    sqlite4_db_release_memory(db);
  }else

  /*
  **  PRAGMA schema_version
  */
  if( sqlite4_stricmp(zPragma, "schema_version")==0 ){
    if( zRight ){
      /* Write the specified cookie value */
      static const VdbeOpList setCookie[] = {
        { OP_Transaction,    0,  1,  0},    /* 0 */
        { OP_Integer,        0,  1,  0},    /* 1 */
        { OP_SetCookie,      0,  0,  1},    /* 2 */
      };
      int addr = sqlite4VdbeAddOpList(v, ArraySize(setCookie), setCookie);
      sqlite4VdbeChangeP1(v, addr, iDb);
      sqlite4VdbeChangeP1(v, addr+1, sqlite4Atoi(zRight));
      sqlite4VdbeChangeP1(v, addr+2, iDb);
    }else{
      /* Read the specified cookie value */
      static const VdbeOpList readCookie[] = {
        { OP_Transaction,     0,  0,  0},    /* 0 */
        { OP_ReadCookie,      0,  1,  0},    /* 1 */
        { OP_ResultRow,       1,  1,  0}
      };
      int addr = sqlite4VdbeAddOpList(v, ArraySize(readCookie), readCookie);
      sqlite4VdbeChangeP1(v, addr, iDb);
      sqlite4VdbeChangeP1(v, addr+1, iDb);
      sqlite4VdbeSetNumCols(v, 1);
      sqlite4VdbeSetColName(v, 0, COLNAME_NAME, zPragma, SQLITE4_TRANSIENT);
    }
  }else

  /*
  ** TODO: This is temporary. There should be some generic way to
  ** pass PRAGMA commands through to KV stores.
  */
  if( sqlite4_stricmp(zPragma, "bt_page_dump")==0 && zRight ){
    bt_info info;
    memset(&info, 0, sizeof(info));
    info.pgno = sqlite4Atoi(zRight);
    sqlite4_buffer_init(&info.output, sqlite4_db_env(db)->pMM);

    rc = sqlite4_kvstore_control(db, zDb, BT_CONTROL_INFO, (void*)&info);
    if( rc==SQLITE4_OK ){
      sqlite4VdbeSetNumCols(v, 1);
      sqlite4VdbeSetColName(v, 0, COLNAME_NAME, "info", SQLITE4_STATIC);
      sqlite4VdbeAddOp2(v, OP_String8, 0, 1);
      sqlite4VdbeChangeP4(v, -1, (char*)info.output.p, P4_TRANSIENT);
      sqlite4VdbeAddOp2(v, OP_ResultRow, 1, 1);
    }
    sqlite4_buffer_clear(&info.output);
  }else

 
  {/* Empty ELSE clause */}



 pragma_out:
  sqlite4DbFree(db, zPragma);
  /* sqlite4DbFree(db, zRight); */
  sqlite4ExprListDelete(db, pList);
}

#endif /* SQLITE4_OMIT_PRAGMA */
